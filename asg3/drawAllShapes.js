var g_map=[
   // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
   // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
   // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
]

// Batched floor: one draw call for all blocky floor with grass texture (good FPS)
var g_floorBatchedPositions = null;
var g_floorBatchedUVs = null;
function buildBatchedFloor() {
   if (g_floorBatchedPositions) return;
   var blockSize = 0.25;
   var gridSize = 32;
   var unitVerts = [
      0,1,0, 1,1,0, 0,0,0,  0,0,0, 1,0,0, 1,1,0,
      0,1,1, 1,1,1, 0,0,1,  0,0,1, 1,0,1, 1,1,1,
      0,1,0, 1,1,0, 1,1,1,  0,1,1, 0,1,0, 1,1,1,
      0,0,0, 0,0,1, 1,0,0,  1,0,0, 1,0,1, 0,0,1,
      0,0,0, 0,1,0, 0,1,1,  0,1,1, 0,0,0, 0,0,1,
      1,0,0, 1,1,0, 1,1,1,  1,1,1, 1,0,0, 1,0,1
   ];
   // 12 triangles * 3 vertices * 2 UV = 72 (matches unitVerts 36 vertices)
   var unitUVs = [
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0,
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0,
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0,
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0,
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0,
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0
   ];
   var pos = [], uv = [];
   var half = gridSize / 2;
   for (var gx = 0; gx < gridSize; gx++) {
      for (var gz = 0; gz < gridSize; gz++) {
         var tx = (gx - half) * blockSize;
         var tz = (gz - half) * blockSize;
         for (var i = 0; i < unitVerts.length; i += 3) {
            pos.push(unitVerts[i] * blockSize + tx, unitVerts[i+1] * blockSize - 1, unitVerts[i+2] * blockSize + tz);
         }
         for (var k = 0; k < unitUVs.length; k++) uv.push(unitUVs[k]);
      }
   }
   g_floorBatchedPositions = pos;
   g_floorBatchedUVs = uv;
}

// World map 32x32, height 0-4 per cell. Add/delete blocks with R / F (at camera cell).
var g_worldMap = [];
var g_worldBatchedPositions = null;
var g_worldBatchedUVs = null;
var g_worldBatchedDirty = true;
var g_worldBlockSize = 0.25;
var g_worldGridSize = 32;
function initWorldMap() {
   if (g_worldMap.length > 0) return;
   for (var i = 0; i < g_worldGridSize; i++) {
      g_worldMap[i] = [];
      for (var j = 0; j < g_worldGridSize; j++) {
         if (i === 0 || i === g_worldGridSize - 1 || j === 0 || j === g_worldGridSize - 1) {
            g_worldMap[i][j] = 4;
         } else {
            g_worldMap[i][j] = 0;
         }
      }
   }
}
function buildBatchedWorld() {
   initWorldMap();
   var unitVerts = [
      0,1,0, 1,1,0, 0,0,0,  0,0,0, 1,0,0, 1,1,0,
      0,1,1, 1,1,1, 0,0,1,  0,0,1, 1,0,1, 1,1,1,
      0,1,0, 1,1,0, 1,1,1,  0,1,1, 0,1,0, 1,1,1,
      0,0,0, 0,0,1, 1,0,0,  1,0,0, 1,0,1, 0,0,1,
      0,0,0, 0,1,0, 0,1,1,  0,1,1, 0,0,0, 0,0,1,
      1,0,0, 1,1,0, 1,1,1,  1,1,1, 1,0,0, 1,0,1
   ];
   var unitUVs = [
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0,
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0,
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0,
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0,
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0,
      0,0, 1,0, 1,1,  0,1, 1,1, 0,0
   ];
   var pos = [], uv = [];
   var half = g_worldGridSize / 2;
   for (var gx = 0; gx < g_worldGridSize; gx++) {
      for (var gz = 0; gz < g_worldGridSize; gz++) {
         var h = g_worldMap[gx][gz];
         if (h <= 0) continue;
         var tx = (gx - half) * g_worldBlockSize;
         var tz = (gz - half) * g_worldBlockSize;
         for (var layer = 0; layer < h; layer++) {
            var ty = -0.75 + layer * g_worldBlockSize; // on top of floor (floor top is -0.75)
            for (var i = 0; i < unitVerts.length; i += 3) {
               pos.push(unitVerts[i] * g_worldBlockSize + tx, unitVerts[i+1] * g_worldBlockSize + ty, unitVerts[i+2] * g_worldBlockSize + tz);
            }
            for (var k = 0; k < unitUVs.length; k++) uv.push(unitUVs[k]);
         }
      }
   }
   g_worldBatchedPositions = pos.length > 0 ? pos : null;
   g_worldBatchedUVs = uv.length > 0 ? uv : null;
   g_worldBatchedDirty = false;
}
function isPerimeterCell(gx, gz) {
   return gx === 0 || gx === g_worldGridSize - 1 || gz === 0 || gz === g_worldGridSize - 1;
}
function addBlockAt(gx, gz) {
   initWorldMap();
   if (gx < 0 || gx >= g_worldGridSize || gz < 0 || gz >= g_worldGridSize) return false;
   if (isPerimeterCell(gx, gz)) return false;
   if (g_worldMap[gx][gz] >= 4) return false;
   g_worldMap[gx][gz]++;
   g_worldBatchedDirty = true;
   return true;
}
function removeBlockAt(gx, gz) {
   initWorldMap();
   if (gx < 0 || gx >= g_worldGridSize || gz < 0 || gz >= g_worldGridSize) return false;
   if (isPerimeterCell(gx, gz)) return false;
   if (g_worldMap[gx][gz] <= 0) return false;
   g_worldMap[gx][gz]--;
   g_worldBatchedDirty = true;
   return true;
}
function getCellFromWorld(x, z) {
   var half = g_worldGridSize / 2;
   var gx = Math.floor(x / g_worldBlockSize + half);
   var gz = Math.floor(z / g_worldBlockSize + half);
   gx = Math.max(0, Math.min(g_worldGridSize - 1, gx));
   gz = Math.max(0, Math.min(g_worldGridSize - 1, gz));
   return { gx: gx, gz: gz };
}

function getGroundHeight(x, z) {
   initWorldMap();
   var cell = getCellFromWorld(x, z);
   var h = g_worldMap[cell.gx][cell.gz];
   var floorTop = -0.75;
   if (h <= 0) return floorTop;
   return floorTop + h * g_worldBlockSize;
}

function getCellFromRay(eyeX, eyeY, eyeZ, atX, atY, atZ, isForAdd) {
   initWorldMap();
   var dx = atX - eyeX, dy = atY - eyeY, dz = atZ - eyeZ;
   var len = Math.sqrt(dx*dx + dy*dx + dz*dz);
   if (len < 1e-6) return null;
   
   dx /= len; dy /= len; dz /= len;
   
   var step = 0.02; // Smaller step for better precision
   var maxDist = 10; // Reach distance
   
   var lastValidGx = null;
   var lastValidGz = null;

   for (var t = 0; t < maxDist; t += step) {
      var px = eyeX + t*dx, py = eyeY + t*dy, pz = eyeZ + t*dz;
      var cell = getCellFromWorld(px, pz);
      
      var h = g_worldMap[cell.gx][cell.gz];
      var floorTop = -0.75;
      var blockTop = floorTop + h * g_worldBlockSize;

      // Check if the ray hit a block or the floor
      if (py <= blockTop) {
         if (isForAdd) {
            // Return the coordinates just before we hit the block
            return (lastValidGx !== null) ? { gx: lastValidGx, gz: lastValidGz } : null;
         } else {
            // Return the actual block we hit
            return { gx: cell.gx, gz: cell.gz };
         }
      }
      
      // Update the "previous" cell only if it's different from the current one
      lastValidGx = cell.gx;
      lastValidGz = cell.gz;
   }
   return null;
}

function drawAllShapes(){
   // Colors
   var wool = [.62, .77, .64, 1.0];
   var skin = [1, .91, .65, 1.0];

   // Wall is drawn as part of world blocks (perimeter cells height 4, no gaps)
   // body =====================================
   var body = new Cube();
   body.color = wool;
   body.textureNum = -2;
   body.matrix.rotate(170, 0, 1, 0);
   body.matrix.scale(.25, 0.25, 0.35);
   body.matrix.translate(-.5, 0, -0.25);
   body.renderfast();

   // head =====================================

   var head = new Cube();
   head.color = wool;
   head.textureNum = -2;
   head.matrix.rotate(170, 0, 1, 0);
   head.matrix.rotate(-head_animation, 1, 0, 0);
   head.matrix.scale(0.35, 0.35, 0.35);
   head.matrix.translate(-.5, 0.25, -1.25);
   head.renderfast();

   var face = new Cube();
   face.color = skin;
   face.textureNum = -2;
   face.matrix.rotate(170, 0, 1, 0);
   face.matrix.rotate(-head_animation, 1, 0, 0);
   face.matrix.scale(0.30, 0.30, 0.03);
   face.matrix.translate(-.5, 0.35, -15.5);
   face.renderfast();

   var tophair = new Cube();
   tophair.color = wool;
   tophair.textureNum = -2;
   tophair.matrix.rotate(170, 0, 1, 0);
   tophair.matrix.rotate(-head_animation, 1, 0, 0);
   tophair.matrix.scale(0.32, 0.071, 0.04);
   tophair.matrix.translate(-.5, 4.85, -11.95);
   tophair.renderfast();

   var botlefthair = new Cube();
   botlefthair.color = wool;
   botlefthair.textureNum = -2;
   botlefthair.matrix.rotate(170, 0, 1, 0);
   botlefthair.matrix.rotate(-head_animation, 1, 0, 0);
   botlefthair.matrix.scale(0.05, 0.071, 0.04);
   botlefthair.matrix.translate(-3.01, 1.5, -11.95);
   botlefthair.renderfast();

   var botrighthair = new Cube();
   botrighthair.color = wool;
   botrighthair.textureNum = -2;
   botrighthair.matrix.rotate(170, 0, 1, 0);
   botrighthair.matrix.rotate(-head_animation, 1, 0, 0);
   botrighthair.matrix.scale(0.05, 0.071, 0.04);
   botrighthair.matrix.translate(2.01, 1.5, -11.95);
   botrighthair.renderfast();

   var lefteye = new Cube();
   lefteye.color = [1,1,1,1];
   lefteye.matrix.rotate(170, 0, 1, 0);
   lefteye.matrix.rotate(-head_animation, 1, 0, 0);
   lefteye.matrix.scale(0.1, 0.061, 0.04);
   lefteye.matrix.translate(-1.5, 3.5, -11.95);
   lefteye.renderfast();

   var lefteyeblack = new Cube();
   lefteyeblack.color = [0,0,0,1];
   lefteyeblack.matrix.rotate(170, 0, 1, 0);
   lefteyeblack.matrix.rotate(-head_animation, 1, 0, 0);
   lefteyeblack.matrix.scale(0.05, 0.061, 0.04);
   lefteyeblack.matrix.translate(-3.001, 3.5, -12);
   lefteyeblack.renderfast();

   var righteye = new Cube();
   righteye.color = [1,1,1,1];
   righteye.matrix.rotate(170, 0, 1, 0);
   righteye.matrix.rotate(-head_animation, 1, 0, 0);
   righteye.matrix.scale(0.1, 0.061, 0.04);
   righteye.matrix.translate(0.5, 3.5, -11.95);
   righteye.renderfast();

   var righteyeblack = new Cube();
   righteyeblack.color = [0,0,0,1];
   righteyeblack.matrix.rotate(170, 0, 1, 0);
   righteyeblack.matrix.rotate(-head_animation, 1, 0, 0);
   righteyeblack.matrix.scale(0.05, 0.061, 0.04);
   righteyeblack.matrix.translate(2.001, 3.5, -12.05);
   righteyeblack.renderfast();

   var mouth = new Cube();
   mouth.color = [1,.79,.69,1];
   mouth.matrix.rotate(170, 0, 1, 0);
   mouth.matrix.rotate(-head_animation, 1, 0, 0);
   mouth.matrix.scale(0.1, 0.071, 0.04);
   mouth.matrix.translate(-0.47, 1.5, -11.95);
   mouth.renderfast()

   var tongue = new Cube();
   tongue.color = [.89,.69,.64,1];
   tongue.matrix.rotate(170, 0, 1, 0);
   tongue.matrix.rotate(-head_animation, 1, 0, 0);
   tongue.matrix.scale(0.1, 0.035, 0.04);
   tongue.matrix.translate(-0.4701, 3, -12);
   tongue.renderfast()

   // upper legs ============================
   var frontleft = new Cube();
   frontleft.color = wool;
   frontleft.textureNum = -2;
   frontleft.matrix.setTranslate(0, 0, 0);
   frontleft.matrix.rotate(-g_jointAngle, 0, 0, 1); // Joint 1
   var frontleftCoord = new Matrix4(frontleft.matrix);
   frontleft.matrix.rotate(170, 0, 1, 0);
   frontleft.matrix.scale(.10, -0.12, 0.10);
   frontleft.matrix.translate(-1.15, -.25, -0.75);
   frontleft.renderfast();

   var frontright = new Cube();
   frontright.color = wool;
   frontright.textureNum = -2;
   frontright.matrix.setTranslate(0, 0, 0);
   frontright.matrix.rotate(g_jointAngle, 0, 0, 1); // Joint 1
   var frontrightCoord = new Matrix4(frontright.matrix);
   frontright.matrix.rotate(170, 0, 1, 0);
   frontright.matrix.scale(.10, -0.12, 0.10);
   frontright.matrix.translate(.2, -.25, -0.75);
   frontright.renderfast();

   var backleft = new Cube();
   backleft.color = wool;
   backleft.textureNum = -2;
   backleft.matrix.setTranslate(0, 0, 0);
   backleft.matrix.rotate(-g_jointAngle, 0, 0, 1); // Joint 1
   var backleftCoord = new Matrix4(backleft.matrix);
   backleft.matrix.rotate(170, 0, 1, 0);
   backleft.matrix.scale(.10, -0.12, 0.10);
   backleft.matrix.translate(-1.15, -.25, 1.5);
   backleft.renderfast();

   var backright = new Cube();
   backright.color = wool;
   backright.textureNum = -2;
   backright.matrix.setTranslate(0, 0, 0);
   backright.matrix.rotate(g_jointAngle, 0, 0, 1); // Joint 1
   var backrightCoord = new Matrix4(backright.matrix);
   backright.matrix.rotate(170, 0, 1, 0);
   backright.matrix.scale(.10, -0.12, 0.10);
   backright.matrix.translate(.2, -.25, 1.5);
   backright.renderfast();



   // lower leg =======================================
   var frontleftlow = new Cube();
   frontleftlow.color = skin;
   frontleftlow.matrix = frontleftCoord;
   frontleftlow.matrix.rotate(170, 0, 1, 0);
   frontleftlow.matrix.rotate(-g_jointAngle2, 0, 0, 1);
   frontleftlow.matrix.scale(0.08, 0.10, 0.08);
   frontleftlow.matrix.translate(-1.25, -1.82, -.8);
   frontleftlow.renderfast();

   var frontrightlow = new Cube();
   frontrightlow.color = skin;
   frontrightlow.matrix = frontrightCoord;
   frontrightlow.matrix.rotate(170, 0, 1, 0);
   frontrightlow.matrix.rotate(g_jointAngle2, 0, 0, 1);
   frontrightlow.matrix.scale(0.08, 0.10, 0.08);
   frontrightlow.matrix.translate(.37, -1.82, -.8);
   frontrightlow.renderfast();

   var backleftlow = new Cube();
   backleftlow.color = skin;
   backleftlow.matrix = backleftCoord;
   backleftlow.matrix.rotate(170, 0, 1, 0);
   backleftlow.matrix.rotate(-g_jointAngle2, 0, 0, 1);
   backleftlow.matrix.scale(0.08, 0.10, 0.08);
   backleftlow.matrix.translate(-1.25, -1.82, 2);
   backleftlow.renderfast();

   var backrightlow = new Cube();
   backrightlow.color = skin;
   backrightlow.matrix = backrightCoord;
   backrightlow.matrix.rotate(170, 0, 1, 0);
   backrightlow.matrix.rotate(g_jointAngle2, 0, 0, 1);
   backrightlow.matrix.scale(0.08, 0.10, 0.08);
   backrightlow.matrix.translate(.37, -1.82, 2);
   backrightlow.renderfast();

   // Sky ====================================
   var sky = new Cube();
   sky.color = [.6, .9, .95, 1];
   sky.textureNum = 1;
   sky.matrix.scale(20,20,20);
   sky.matrix.translate(-.5, -.5, -.5);
   sky.render();

   // Blocky Minecraft floor: one batched draw with grass texture (good FPS)
   buildBatchedFloor();
   gl.uniform1i(u_whichTexture, 0);
   gl.uniform4f(u_FragColor, 0.2, 0.9, 0.4, 1);
   var identityM = new Matrix4();
   gl.uniformMatrix4fv(u_ModelMatrix, false, identityM.elements);
   drawBatchedTriangles3DUV(g_floorBatchedPositions, g_floorBatchedUVs);

   // World blocks from 32x32 map (height 0-4). Rebuild when add/delete.
   if (g_worldBatchedDirty) buildBatchedWorld();
   if (g_worldBatchedPositions && g_worldBatchedUVs) {
      gl.uniform1i(u_whichTexture, -2);
      gl.uniform4f(u_FragColor, 0.55, 0.35, 0.2, 1);
      gl.uniformMatrix4fv(u_ModelMatrix, false, identityM.elements);
      drawBatchedTriangles3DUV(g_worldBatchedPositions, g_worldBatchedUVs);
   }
}
